// Copyright 2022 LEXUGE
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pub mod native;
#[cfg(feature = "rune-scripting")]
pub mod rune_scripting;
/// Useful utils to route a query
pub mod utils;

pub mod builders {
    #[cfg(feature = "rhai-scripting")]
    pub use super::rhai_scripting::{RhaiScript, RhaiScriptBuilder};

    #[cfg(feature = "rune-scripting")]
    pub use super::rune_scripting::{RuneScript, RuneScriptBuilder};

    pub use super::native::NativeScriptBuilder;
}

use crate::{Upstreams, Validatable};
use async_trait::async_trait;
use bytes::Bytes;
use domain::base::{
    iana::{class, opcode, rtype},
    name::PushError,
    octets::ParseError,
    Message, ShortBuf,
};
use std::{
    net::{AddrParseError, IpAddr},
    string::FromUtf8Error,
};
use thiserror::Error;

type Result<T> = std::result::Result<T, ScriptError>;

#[derive(Error, Debug)]
/// All possible errors that may incur when using message.
pub enum MessageError {
    /// The record data indicated is currently not supported or mismatched on conversion.
    #[error("Record data not supported or mismatched")]
    RecordUnsupported,

    /// The Opt data indicated is currently not supported or mismatched on conversion.
    #[error("Option not supported or mismatched")]
    OptionUnsupported,

    /// The message has no first question
    #[error("First question not found for the given message")]
    NoFirstQuestion,

    /// Invalid data
    #[error("The IP address type of {0} is not applicable here")]
    InvalidIpAddrType(IpAddr),

    /// Unable to parse from UTF8 bytes
    #[error(transparent)]
    FromUtf8Error(#[from] FromUtf8Error),

    /// Unable to parse Opcode from str
    #[error(transparent)]
    OpcodeFromStrErr(#[from] opcode::FromStrError),

    /// Unable to parse Rtype from str
    #[error(transparent)]
    RtypeFromStrErr(#[from] rtype::FromStrError),

    /// Unable to parse Class from str
    #[error(transparent)]
    ClassFromStrErr(#[from] class::FromStrError),

    /// Unable to parse IP address
    #[error(transparent)]
    AddrParseError(#[from] AddrParseError),

    /// Unable to parse dname
    #[error(transparent)]
    DnameParseError(#[from] domain::base::name::FromStrError),

    /// Unable to parse rcode
    #[error(transparent)]
    RcodeParseError(#[from] domain::base::iana::rcode::FromStrError),

    /// Failed to parse the record
    #[error(transparent)]
    ParseError(#[from] ParseError),

    /// Failed to convert to Dname
    #[error(transparent)]
    PushError(#[from] PushError),

    /// Buffer is too short
    #[error(transparent)]
    ShortBuf(#[from] ShortBuf),
}

/// Errors generated by the `script` module.
#[derive(Error, Debug)]
#[cfg_attr(feature = "rune-scripting", derive(rune::Any))]
pub enum ScriptError {
    /// Buf is too short
    #[error(transparent)]
    ShortBuf(#[from] domain::base::ShortBuf),

    /// Error forwarded from `Utils`
    #[error(transparent)]
    UtilsError(#[from] utils::UtilsError),

    /// Error forwarded from `Messages`
    #[error(transparent)]
    MessageError(#[from] MessageError),

    /// Error forwarded from `Upstreams`
    #[error(transparent)]
    UpstreamError(#[from] crate::errors::UpstreamError),

    /// Rune Emit Error
    #[cfg(feature = "rune-scripting")]
    #[error(transparent)]
    RuneEmitError(#[from] rune::diagnostics::EmitError),

    /// Rune Build Error
    #[cfg(feature = "rune-scripting")]
    #[error(transparent)]
    RuneBuildError(#[from] rune::BuildError),

    /// Rune Context Error
    #[cfg(feature = "rune-scripting")]
    #[error(transparent)]
    RuneContextError(#[from] rune::ContextError),

    /// Rune Vm Error
    #[cfg(feature = "rune-scripting")]
    #[error(transparent)]
    RuneVmError(#[from] rune::runtime::VmError),
}

/// Query Context
#[derive(Clone)]
#[cfg_attr(feature = "rune-scripting", derive(rune::Any))]
pub struct QueryContext {
    /// Query sender's IP address
    pub ip: IpAddr,
}

/// A script backend routes every message with query context and the query itself.
#[async_trait]
pub trait ScriptBackend: Validatable<Error = ScriptError> {
    /// Process the query.
    async fn route(
        &self,
        query: Message<Bytes>,
        ctx: Option<QueryContext>,
    ) -> Result<Message<Bytes>>;
}

/// A script builder is a type that builds itself into a script backend.
#[async_trait(?Send)]
pub trait ScriptBuilder<T: ScriptBackend> {
    /// Build the script backend with upstreams given.
    async fn build(self, upstreams: Upstreams) -> Result<T>;
}
